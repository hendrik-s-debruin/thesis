\section{Trajectory Generation}%
\label{sec:trajectory_generation}

	The problem of trajectory generation can be categorised into one-dimensional
	and multi-dimensional trajectories. A schematic overview is shown in
	Figure~\ref{fig:trajectory_generation_categories}. Techniques exist to generate
	point-to-point trajectories, as well as to generate trajectories that visit
	multiple points. The latter case can be further subdivided into trajectories
	that visit each point exactly (known as interpolation techniques) and
	trajectories that come within a specified tolerance of each point (know as
	approximation techniques).

	\begin{figure}[hb]
		\centering
		\def\svgwidth{\columnwidth}
		\import{res/img/}{trajectory_generation_categories.pdf_tex}
		\caption[Trajectory Generation Categories]
			{Trajectory Generation Categories (adapted
			from~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots})}%
		\label{fig:trajectory_generation_categories}
	\end{figure}

	Trajectories can be generated that have different levels of continuity,
	denoted by $\contdeg{n}$, where $n$ denotes the degree of differentiability
	of the trajectory. It is desirable to have a continuous profile in
	acceleration, since discontinuities in the acceleration profile lead to
	impulse forces in the robot. It is also possible to generate smooth profiles
	in jerk and other higher time derivatives of position.

	One-dimensional trajectories can often be generalised for the
	multi-dimensional case. As such,
	Section~\ref{sec:one_dimensional_trajectory_generation} gives an overview of
	such techniques. Section~\ref{sec:multi_dimensional_trajectory_generation}
	gives an overview of trajectory generation techniques that are directly
	suited for the multi-dimensional case. Finally,
	Section~\ref{sec:trajectory_scaling} reviews methods to deal with
	constraints on higher time derivatives of position.

	\subsection{One Dimensional Trajectory Generation}%
	\label{sec:one_dimensional_trajectory_generation}

		This section describes one dimensional trajectory generation.
		Section~\ref{sec:elementary_trajectories} describes how to generate
		trajectories between points, while
		Section~\ref{sec:trajetory_composition} discusses how elementary
		trajectories may be combined.

		\subsubsection{Elementary Trajectories}%
		\label{sec:elementary_trajectories}

			\paragraph{Polynomial Trajectories}%
			\label{sec:polynomial_trajectories}

				A polynomial $\polynomial$ may be fitted to a set of points
				$\setofpoints$ describing the boundary conditions on
				position $\configuration$,
				velocity $\dot{\configuration}$, acceleration
				$\ddot{\configuration}$, jerk $\tdern{\configuration}{3}$, or
				higher derivatives of a trajectory $\configuration(\timenorm)$.
				A condition of the polynomial is that:

				\begin{equation}
					\deg\polynomial = \poldeg \geq \cardinality{\setofpoints}
				\end{equation}

				The polynomial may be written as:

				\begin{equation}
					\configuration(\timenorm)
						= \polynomial
						= \sum_{\indexi=0}^{\poldeg}
						\coefficient_{\indexi} \timenorm^{\indexi}
				\end{equation}

				This may be rewritten in matrix form as follows:

				\begin{equation}
					\mat{M}\vec{\coefficient} = \boundaryconditions
					\label{eq:polynomial_coefficient_equation}
				\end{equation}

				Where the coefficients to be solved are put into
				\(
					\vec{\coefficient} =
						{
							\left[
								\begin{matrix}
									\coefficient_0 &
									\cdots &
									\coefficient_{\poldeg}
								\end{matrix}
							\right]
						}^T
				\),
				the boundary conditions are
				\(
					\boundaryconditions =
						{
							\left[
								\begin{matrix}
									\configuration_0 &
									\dot{\configuration}_0 &
									\cdots &
									\tdern{\configuration_0}{n} &
									\configuration_{\final} &
									\dot{\configuration}_{\final} &
									\cdots &
									\tdern{\configuration_{\final}}{n}
								\end{matrix}
							\right]
						}^T
				\)
				and $\mat{M}$ is filled by factorising the polynomials.

				In principle, the trajectory may be obtained by setting:

				\begin{equation}
					\vec{\coefficient} = {\mat{M}}^{-1}\vec{b}
				\end{equation}

				However, taking the inverse of a matrix explicitly like this can
				lead to numerical instability even for a low degree polynomial.
				Other numerical techniques should be used for poorly conditioned
				matrices.


			\paragraph{Trigonometric Trajectories}%
			\label{trigonometric_trajectories}

				Several types of trajectories can be generated by using
				trigonometric functions. Such trajectories have the advantage
				that they are of type
				\(
					\contdeg{\infty}
				\), with non-zero derivatives
				\(
					\forall \timesym \in [0, \timesym_{\final}]
				\).
				If proper care is taken in defining the boundary conditions,
				these trajectories can be used for continuous cyclic motions.

				\begin{itemize}

					\item %HARMONIC

						Harmonic Trajectories are designed such that the
						acceleration of the trajectory is proportional to its
						position. Such trajectories are expressed by:

						\begin{equation}
							\configuration(\timesym) =
								\frac{%
										\configuration_{\final} - \configuration_0
									}
									{%
										2
									}
								\left(
									1 - \cos
										\frac{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
								\right)
								+ \configuration_0
						\end{equation}

						Note that this trajectory is discontinuous in its
						acceleration profile at the boundaries.

					\item %ELLIPTICAL

						Elliptical trajectories are a generalised form of
						harmonic trajectories.  They are of the following form:

						\begin{equation}
							\configuration(\timesym) =
								\frac
								{%
									\configuration_{\final} - \configuration_0
								}
								{%
									2
								}
								\left(
									1 -
									\frac
									{%
										\cos\frac
											{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
									}
									{%
										\sqrt
										{%
											1 -
											\frac
											{%
												\gain^2 - 1
											}
											{%
												\gain^2
											}
											\sin^2\frac
											{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
										}
									}
								\right)
						\end{equation}

						$\gain$ denotes a tunable parameter. Higher values of
						$\gain$ lead to higher values maxima in the time
						derivatives of position.

					\item %CYCLOIDAL

						Cycloidal trajectories obtain a continuous acceleration
						profile
						\(
							\forall \timesym \in [\timesym_0, \timesym_{\final}]
						\).
						These are given by the expression:

						\begin{equation}
							\configuration(\timesym) =
								(\configuration_{\final} - \configuration_0)
								\left(
									\frac
									{%
										\timesym - \timesym_0
									}
									{%
										\timesym_{\final} - \timesym_0
									}
									-
									\frac
									{%
										1
									}
									{%
										2\pi
									}
									\sin
										\frac
										{%
											2\pi(\timesym - \timesym_0)
										}
										{%
											\timesym_{\final} - \timesym_0
										}
								\right)
								+ \configuration_0
						\end{equation}

						Due to the continuous acceleration profile, these
						trajectories are suitable for mechanisms with flexible
						components.

				\end{itemize}

			\paragraph{Exponential Trajectories}%
			\label{exponential_trajectories}

				Exponential trajectories may be constructed such that the degree
				of continuity of the trajectory may be
				adjusted~\cite{bib:traj:cam_mechanisms}.  These trajectories are
				exponential in their velocity profiles, therefore their position
				profile is given by the following expression:

				\begin{equation}
					\configuration(\timenorm) = \gain_1\int_{0}^{\timenorm}
						e^{-\gain_2 f(\timenorm, \gain_3)} \der \timenorm
				\end{equation}

				A popular choice for $f$ is~\cite[][page
				48]{bib:traj:trajectory_planning_for_automatic_machines_and_robots}:

				\begin{equation}
					f(\timenorm, \gain_3) =
						\frac
						{%
							{(2\timenorm)}^2
						}
						{%
							{%
								\left|
									1 - {(2\timenorm)}^2
								\right|
							}^{\gain_3}
						}
				\end{equation}

				$\gain_2$ and $\gain_3$ may be chosen to minimise high frequency
				components in the acceleration. By tuning these parameters,
				vibrations induced by the trajectory can be lowered.

			\paragraph{Trajectories Based on Fourier Series Expansion}%
			\label{trajectories_based_on_fourier_series_expansion}

				Given any of the previous trajectories of this section, one may
				want to attempt to limit vibrations induced by the trajectory.
				One method, which is especially useful for periodic
				trajectories, is the use of Fourier series expansion.

				A trajectory $\configuration(\timesym)$ may be transformed as
				follows:

				\begin{enumerate}

					\item

						Expand $\configuration(\timesym)$ into its Fourier
						series.

					\item

						Take the first $\gain$ terms of this series and use it to
						define a new trajectory $\configuration'(\timesym)$.

				\end{enumerate}

				The number of terms, $\gain$, of the expansion to use
				compromises a trade-off: higher $\gain$ leads to lower maximum
				acceleration, but higher frequency components.

		\subsubsection{Trajectory Composition}%
		\label{sec:trajetory_composition}

			Trajectories such as those presented in
			Section~\ref{sec:elementary_trajectories} may be combined to obtain
			new trajectories. The problem is then to smoothly connect these
			trajectories with trajectory segments referred to as
			``bends''~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots}.

			Many of the composition techniques break the trajectory into an
			acceleration phase, a trajectory phase, and a deceleration phase.

			\paragraph{Circular Bends}%
			\label{circular_bends}

				Circular Bends can be added to the position profile of a linear
				trajectory to start the trajectory segment from rest or to bring
				it to rest. Given a base linear trajectory,
				$\configuration(\timesym)$, the full trajectory
				$\configuration'(\timesym)$ is given  by:

				\begin{equation}
					\configuration'(\timesym) =
						\begin{cases}
							(\configuration_{\final} - \configuration_0)
							\left(
								1 - \sqrt
									{%
										1 - \frac
											{%
												{(\timesym - \timesym_0)}^2
											}
											{%
												{(\configuration_{\final} -
												\configuration_0)}^2
											}
									}
							\right)
							+ \configuration_0
							%
							& \timesym \in [\timesym_0, \timesym_1]
							%
							\\
							%
							\configuration(\timesym)
							%
							& \timesym \in [\timesym_1, \timesym_2]
							%
							\\
							%
							\configuration_0 +
								\sqrt
									{%
										{(\configuration_{\final} -
										\configuration_0)}^2
										-
										{(\timesym_{\final} - \timesym)}^2
									}
							%
							& \timesym \in [\timesym_2, \timesym_{\final}]
						\end{cases}
				\end{equation}

				The time intervals must be chosen such that:

				\begin{equation}
					\begin{cases}
						\configuration'(\timesym \in [\timesym_0,
							\timesym_1])|_{\timesym_1}
							=
							\configuration'(\timesym \in [\timesym_1,
								\timesym_2])|_{\timesym_1}
						%
						\\
						%
						\dot{\configuration}'(\timesym \in [\timesym_0,
							\timesym_1])|_{\timesym_1}
							=
							\dot{\configuration}'(\timesym \in [\timesym_1,
								\timesym_2])|_{\timesym_1}
					\end{cases}
				\end{equation}

			\paragraph{Polynomial Bends}%
			\label{polynomial_bends}

				Another method of starting or stopping a trajectory, or of
				joining different trajectory segments, is through the use of
				polynomial bends. The degree of smoothness of the connections
				can be controlled by choosing the degree of the polynomial
				bends. Given a base trajectory, $\configuration(\timesym)$, a
				new trajectory with polynomial bends,
				$\configuration'(\timesym)$ can be defined as follows:

				\begin{equation}
					\configuration'(\timesym) =
					\begin{cases}
						\configuration_1(\timesym) & \timesym \in [\timesym_0, \timesym_1] \\
						\configuration(\timesym) & \timesym \in [\timesym_1, \timesym_2] \\
						\configuration_2(\timesym) & \timesym \in [\timesym_2, \timesym_{\final}] \\
					\end{cases}
					\label{eq:polynomial_bends}
				\end{equation}

				Here, $\configuration_a$ and $\configuration_b$ may be computed
				using the polynomial trajectory method of
				Section~\ref{sec:elementary_trajectories}.

			%	\todo{for this section, reference bookref 17. The book
			%	references it on page 117. This section is a combination of
			%	various sections from the book}

			\todo{maybe add a discussion on the trapezoidal trajectories?}

			\paragraph{Cycloidal and Harmonic Blends}%
			\label{cycloidal_and_harmonic_blends}

				We may also connect trajectory segments with sinusoidal
				profiles described in Section~\ref{sec:elementary_trajectories}.
				The clear advantage of these bends are that they are of type
				$\contdeg{\infty}$.

				Again, the new trajectory $\configuration'(\timesym)$ is given
				by Equation~\ref{eq:polynomial_bends}, where
				$\configuration_1(\timesym)$ and $\configuration_2(\timesym)$
				are now one of the trigonometric functions of
				Section~\ref{sec:elementary_trajectories}.

	\subsection{Multipoint Trajectories}%
	\label{sec:multipoint_trajectories}

		The techniques from
		Section~\ref{sec:one_dimensional_trajectory_generation} are concerned
		with generating trajectories between two points. The present section
		documents methods to generate a trajectory that goes through all the
		points $\point$ in a given set of points $\setofpoints$.

		Trajectories that interpolate points exactly are discussed in
		Section~\ref{sec:interpolation_techniques}, while trajectories that
		approximate points can be found in
		Section~\ref{sec:approximation_techniques}.

		One approach to multipoint trajectories is to define a set of primitive
		trajectories, such as straight lines or circles, and then to connect
		these disjoint trajectories smoothly with the blending techniques
		discussed in Section~\ref{sec:trajetory_composition}. The remainder of
		this section will review other approaches to multi-point trajectory
		generation.

		\subsubsection{Interpolation Techniques}%
		\label{sec:interpolation_techniques}

			The current section summarises some multipoint interpolation
			techniques.

			\paragraph{Multipoint Polynomial Trajectories}%
			\label{sec:multipoint_polynomial_trajectories}

				The polynomial method of
				Section~\ref{sec:polynomial_trajectories} can be extended to
				exactly interpolate a set of points. This is done by simply
				adjusting the vector $\boundaryconditions$ to also include the
				intermediate points. A polynomial of degree $\poldeg$ can be
				used to interpolate $\poldeg + 1$ points.

				The main disadvantage is that polynomials tend to overshoot a
				lot between points.

			\paragraph{Trigonometric Polynomials}%
			\label{sec:trigonometric_polynomials}

				Trigonometric polynomials are similar to regular polynomials,
				except they are suitable for periodic
				motions~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots}.
				By definition, these trajectories are of type
				$\contdeg{\infty}$. They are given by the expression:

				\begin{equation}
					\configuration(\timesym) =
						\coefficient_0 +
						%
						\sum_{\indexi = 1}^{\poldeg} \coefficient_{\indexi}
							\cos
							\left(
								\indexi\frac
								{%
									2\pi\timesym
								}
								{%
									\period
								}
							\right)
						%
						+
						%
						\sum_{\indexi = 1}^{\poldeg}\coefficientb_{\indexi}
							\sin
							\left(
								\indexi\frac{%
									2\pi\timesym
								}
								{%
									\period
								}
							\right)
				\end{equation}

				The degree of the polynomial $\poldeg$ is chosen such that
				$\cardinality{\setofpoints} = 2\poldeg + 1$. The coefficients
				are solved using the same method of polynomial trajectories. A
				set of these polynomials may be joined to form a trigonometric
				spline. %\todo{ref book ref 27, 28, 29. See p 175}

			\paragraph{Splines}%
			\label{sec:splines}

				$\cardinality{\setofpoints} - 1$ polynomials of degree usually
				set to $\poldeg \leq \cardinality{\setofpoints} - 2$ may be used
				to form a spline interpolation. The main idea is to use each
				polynomial to interpolate between two points. The polynomial
				degree $\poldeg$ and the boundary conditions in
				Equation~\ref{eq:polynomial_coefficient_equation} are then
				chosen to ensure that the splines meet with a desired level of
				continuity.

				A common choice for the degree of the polynomial is $\poldeg =
				3$. This ensures that accelerations remain continuous at the
				transitions. Furthermore, it is easy to set the start and end
				conditions to be continuous up to a required degree in order to
				make the trajectories periodic.

		\subsubsection{Approximation Techniques}%
		\label{sec:approximation_techniques}

			Multipoint approximation techniques are summarised in the current
			section.

			\todo{orthogonal polynomials --- p 165}

			\paragraph{Smoothing Cubic Splines}%
			\label{sec:smoothing_cubic_splines}

				Smoothing cubic splines are an adaptation on the spline
				interpolation of Section~\ref{sec:splines}. They try to have as
				good as possible a fit of the points in $\setofpoints$, yet try
				to limit the curvature of the trajectory. This tends to reduce
				the acceleration profile.

				Such trajectories try to solve for the spline polynomials
				$\polynomial$ satisfying:

				\begin{equation}
					\argmin_{\polynomial}
					\left\{
						\relweight
						\underbrace{%
							\sum_{\indexi = 0}^{\cardinality{\setofpoints}}
								\gain_{\indexi}
								{%
									\left(
										\polynomial(\timesym_{\indexi}) -
										\point_{\indexi}
									\right)
								}^2
						}_{\text{error in approximation}}
						+
						(1 - \relweight)
						\underbrace{%
							\int_{\timesym_0}^{\timesym_{\cardinality{\setofpoints}}}
								\ddot{\polynomial}^2
							\der \timesym
						}_{\text{curvature}}
					\right\}
					\label{eq:smoothing_cubic_splines_criterion}
				\end{equation}

				$\relweight\in[0, 1]$ denotes the relative weight of a factor.

				An algorithm based on linear algebra techniques to solve
				Equation~\ref{eq:smoothing_cubic_splines_criterion} can be found
				in~\cite[][page 180]{bib:traj:trajectory_planning_for_automatic_machines_and_robots}.

				The maximum approximation error can be guaranteed by performing
				a simple search technique, such as binary search, on the
				parameter $\relweight$.

	\subsection{Multi-Dimensional Trajectory Generation}%
	\label{sec:multi_dimensional_trajectory_generation}

		It is often possible to decompose multi-dimensional trajectories into
		simpler components. Trajectories for these components may be handled by
		the techniques discussed in
		Sections~\ref{sec:one_dimensional_trajectory_generation}
		and~\ref{sec:multipoint_trajectories}. The remainder of this section
		deals with trajectory generation techniques that deal directly with the
		multi-dimensional case.

		The trajectories given in this section are of the form
		$\traj(\timenorm)$. Here, the trajectory $\traj$ defines a curve in
		space. $\timenorm(\timesym)$ acts as a motion law that determines when
		certain points in the trajectory are reached. Therefore, a trajectory
		for $\timenorm$ can be generated with any of the one dimensional methods
		described in Section~\ref{sec:one_dimensional_trajectory_generation}
		or~\ref{sec:multipoint_trajectories}. The motion law $\timenorm$ can
		also be chosen to adhere to some kinematic and dynamic constraints.
		Section~\ref{sec:trajectory_scaling} deals with this.

		\subsubsection{Multi-Dimensional Interpolation Trajectories}%
		\label{sec:multi_dimensional_interpolation_trajectories}

			\paragraph{B-Splines}%
			\label{sec:b_spines}

				B-splines are a common method to interpolate between points
				$\point$ in a given set
				$\setofpoints$~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots}\cite{bib:traj:handbook_on_splines_for_the_user}.
				They are given by the relation:

				\begin{equation}
					\traj = \sum_{\indexi = 0}^{\cardinality{\setofpoints}}
						\point_{\indexi}\bspline_{\indexi}^{\poldeg}(\timenorm)
					\label{eq:bspline}
				\end{equation}

				Where the superscript denotes the degree of the spline
				$\bspline$. The points $\point_{\indexi}$ are known as the
				control points of Equation~\ref{eq:bspline}.  Each B-spline
				meets at a point known as a knot $\knot$. Given an ordered set
				of knots such that
				\(
					\knot_{\indexi} \prec \knot_{\indexj} \iff \indexi < \indexj
				\), a basis spline $\bspline$ is defined as follows:

				\begin{align}
					\begin{split}
						\bspline_{\indexi}^0(\timenorm) &=
							\begin{cases}
								1, & \timenorm \in [\knot_{\indexi}, \knot_{\indexi + 1}]\\
								0, & \text{otherwise}
							\end{cases}
						%
						\\
						%
						\bspline_{\indexi}^{\poldeg}(\timenorm) &=
							\frac
							{%
								\timenorm - \knot_{\indexi}
							}
							{%
								\knot_{\indexi + \poldeg} - \knot_{\indexi}
							}
							\bspline_{\indexi}^{\poldeg - 1}(\timenorm)
							+
							\frac
							{%
								\knot_{\indexi + \poldeg + 1} - \timenorm
							}
							{%
								\knot_{\indexi + \poldeg + 1} - \knot_{\indexi + 1}
							}
							\bspline_{\indexi + 1}^{\poldeg - 1}(\timenorm)
							,
							\quad \poldeg > 0
						\label{eq:bspline_interpolation_generation}
						\end{split}
				\end{align}

				%The following constraint is added to normalise the spline
				%functions:

				%\begin{equation}
				%	\sum_{\indexi = 0}^{\cardinality{\setofpoints}}
				%		\bspline_{\indexi}^{\poldeg}(\timenorm)
				%		=
				%		1
				%		\quad \forall \timenorm
				%\end{equation}

				Setting the degree of the B-spline curve to $\poldeg$ imposes a
				continuity level of $\contdeggeom{\poldeg - 1}$.
		\label{sec:multi_dimensional_approximation_trajectories}

			\paragraph{Linear Interpolation with Polynomial Bends}%
			\label{sec:linear_interpolation_with_polynomial_bends}

				Linear interpolation with polynomial bends is a very simple way
				to approximate the points $\point\in\setofpoints$ to within a
				specifiable tolerance $\tol$ and a specified degree of
				smoothness.  Consider an ordered set of points $\setofpoints$
				such that $\point_{\indexi} \prec \point_{\indexj} \iff \indexi
				\leq \indexj$. For the internal points the following basic
				algorithm can be used to generate an interpolation
				\(
					\forall \point \in
						\setofpoints\setminus
							\left\{
								\point_0,
								\point_{\cardinality{\setofpoints}}
							\right\}
				\):

				\begin{enumerate}

					\item

						Construct a (hyper)sphere of radius $\tol$ around point
						$\point_{\indexi}$.

					\item

						Connect points
						\(
							(
								\point_{\indexi - 1},
								\point_{\indexi},
								\point_{\indexi + 1}
							)
						\)
						with the straight lines
						\(
							\vecline{
								\point_{\indexi -1}
							}
							{
								\point_{\indexi}
							}
						\)
						and
						\(
							\vecline{
								\point_{\indexi}
							}
							{
								\point_{\indexi+1}
							}
						\).

					\item

						Mark the intersection of the line
						\(
							\vecline{
								\point_{\indexi -1}
							}
							{
								\point_{\indexi}
							}
						\)
						and the sphere as the point $\point_{\indexi}'$, and the
						intersection of the line
						\(
							\vecline{
								\point_{\indexi}
							}
							{
								\point_{\indexi+1}
							}
						\) and the sphere as the point $\point_{\indexi}''$.

					\item

						The trajectory $\traj$ that is guaranteed to come within
						$\tol$ of the current point $\point_{\indexi}$
						is then defined by:

						\begin{equation}
							\traj_{\indexi}(\timenorm) =
								\begin{cases}
									\vecline{%
										\point_{\indexi -1}
									}
									{%
										\point_{\indexi}
									},
									& \traj(\timenorm)\mapsto
										[
											\point_{\indexi-1},
											\point_{\indexi}'
										]
									%
									\\
									%
									\traj'(\timenorm),
									& \traj(\timenorm)\mapsto
										[
											\point_{\indexi}',
											\point_{\indexi}''
										]
									%
									\\
									%
									\vecline{%
										\point_{\indexi}
									}
									{%
										\point_{\indexi+1}
									},
									& \traj(\timenorm)\mapsto
										[
											\point_{\indexi}'',
											\point_{\indexi+1}
										]
								\end{cases}
						\end{equation}

						Where $\traj'$ is the part of the trajectory $\traj$
						between points $\point_{\indexi}'$ and
						$\point_{\indexi}''$ and is given by a polynomial
						function such as a B-spline discussed in
						Section~\ref{sec:b_spines}. The result is straight lines
						smoothly connected with bends.

				\end{enumerate}

				The end points of $\setofpoints$,  points $\point_0$ and
				$\point_{\cardinality{\setofpoints}}$, may be connected to their
				following/preceding points by simple straight lines.
				Figure~\ref{fig:linear_interpolation_with_polynomial_bends}
				shows a schematic of the effect achieved with this procedure.

				\begin{figure}[hb]
					\centering
					\def\svgwidth{\columnwidth}
					\import{res/img/}{linear_interpolation_with_polynomial_bends.pdf_tex}
					\caption[Linear Interpolation with Polynomial Bends]
						{Linear Interpolation with Polynomial Bends (adapted
						from~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots})}%
					\label{fig:linear_interpolation_with_polynomial_bends}
				\end{figure}

			\paragraph{Smoothing Cubic B-Splines}%
			\label{sec:smoothing_cubic_b_splines}

				In a spirit similar to smoothing cubic splines, B-splines may be
				made to approximate points to within a given tolerance $\tol$.
				The splines are of the form in Equation~\ref{eq:bspline}.

				A smoothing cubic B-spline is defined by a set of points $\point
				\in \setofpoints$ which need to be approximated by the control
				points $\approximation{\point} \in \approximation{\setofpoints}$
				(which replace the points $\point$ in Equation~\ref{eq:bspline})
				at given points of time $\timenorm \in \setoftimeinstants$.
				Instead of defining the splines with the recursive procedure
				given in Equation~\ref{eq:bspline_interpolation_generation}, a
				minimisation needs to be performed. This minimisation is
				analogous to the cubic spline case,
				Equation~\ref{eq:smoothing_cubic_splines_criterion}, and is
				given by the expression:

				\begin{equation}
					\approximation{\setofpoints} =
					\argmin_{\approximation{\setofpoints}}
					\left\{
						\relweight
						\underbrace{%
							\sum_{\indexi = 0}^{\cardinality{\setofpoints}}
								\gain_{\indexi}
								{%
									\norm{%
										\traj(\timenorm_{\indexi}) -
										\point_{\indexi}
									}
								}^2
						}_{\text{error in approximation}}
						+
						(1 - \relweight)
						\underbrace{%
							\int_{\timesym_0}^{\timesym_{\cardinality{\setofpoints}}}
								{%
									\norm
									{%
										\frac
										{%
											\der^2 \traj(\timenorm)
										}
										{%
											\der\timenorm^2
										}
									}
								}^2
							\der \timenorm
						}_{\text{total curvature}}
					\right\}
					\label{eq:smoothing_b_splines_criterion}
				\end{equation}

				Note that $\gain_{\indexi}$ may be set to change the
				approximation error in some specific points. A methodology to
				perform this minimisation can be found in~\cite[][page
				371]{bib:traj:trajectory_planning_for_automatic_machines_and_robots}

			\todo{Mixed Interpolation/Approximation, book p 375}


	\subsection{Trajectory Scaling}%
	\label{sec:trajectory_scaling}

		Given a trajectory $\configuration(\timesym)$, one may perform several
		scaling techniques to ensure actuators do not exceed saturation
		constraints. Trajectories may be scaled to avoid kinematic saturation
		(that is, saturation in velocities, acceleration or higher derivatives),
		or to avoid dynamic saturation (that is, saturation in the torques
		induced in the actuators).

		\subsubsection{Kinematic Scaling}%
		\label{sec:kinematic_scaling}

			Given a trajectory $\configuration(\timesym)$, it is possible to
			alter the time it takes by considering a new time variable
			$\timesym'$ related to $\timesym$ through some relation:

			\begin{equation}
				\timesym = \function(\timesym')
				\label{eq:time_scaling}
			\end{equation}

			Where $f$ is a strictly increasing function. The new trajectory
			$\configuration'(\timesym')$ and its higher derivates are given by
			the chain rule as:

			\begin{align}
				\begin{split}
					\configuration'(\timesym') &= \configuration(\function(\timesym'))\\
					%
					\dot{\configuration}'(\timesym') &=
						\frac
						{%
							\der \configuration(\function)
						}
						{%
							\der \function
						}
						\frac
						{%
							\der \function(\timesym')
						}
						{%
							\der \timesym'
						}\\
					%
					\ddot{\configuration}'(\timesym') &=
						\frac
						{%
							\der \configuration(\function)
						}
						{%
							\der \function
						}
						\frac
						{%
							\der^2 \function(\timesym')
						}
						{%
							\der \timesym'^2
						}
						+
						\frac
						{%
							\der^2 \configuration(\function)
						}
						{%
							\der \configuration^2
						}
						{%
							\left(
								\frac
								{%
									\der \function(\timesym')
								}
								{%
									\der \timesym'
								}
							\right)
						}^2\\
						%
						&\quad\quad\quad\quad\quad\quad\quad\vdots
					\label{eq:kinematic_scaling_general}
				\end{split}
			\end{align}

			A simple example for $\function$ is the linear function:

			\begin{equation}
				\timesym = \gain\timesym'
				\label{eq:linear_time_scaling}
			\end{equation}

			In this case, Equation~\ref{eq:kinematic_scaling_general} reduces
			to:

			\begin{equation}
				\tdern{\configuration'}{\indexi}(\timesym') = \gain^{\indexi}
					\tdern{\configuration}{\indexi}(\timesym)
			\end{equation}

			Now, given a set of constraints $\setofconstraints$ on the maximum
			velocity, acceleration, or higher derivatives of a trajectory,
			$\gain$ may be chosen as follows:

			\begin{equation}
				\gain = \min
					\left\{
						\sqrt[\indexi]
						{%
							\frac
							{%
								\constraint_{\indexi}
							}
							{%
									\norm
									{%
										\tdern{\configuration}{\indexi}(\timesym)
									}_{\max}
							}
						}
						\quad
						\forall \constraint_{\indexi} \in \setofconstraints
					\right\}
			\end{equation}

			Where $\constraint_{\indexi}$ is the constraint on the $\indexi$th
			derivative of position. This will ensure that $\configuration'$ does
			not exceed these constraints. Here, the 1st root, $\sqrt[1]{\cdot}$,
			is defined to return its argument without change.

		\subsubsection{Dynamic Scaling}%
		\label{sec:dynamic_scaling}

			Given the dynamic model of a system, $\dynamicmodel(\torque)$, the
			same time scaling approach as given in
			Equation~\ref{eq:time_scaling} can be used.

			The torques in the actuators are given by:

			\begin{equation}
				\torque = \invdynamicmodel(\configuration, \dot{\configuration},
					\ddot{\configuration})
				\label{eq:inv_dynamic_model_scaling}
			\end{equation}

			Equation~\ref{eq:inv_dynamic_model_scaling} can usually be expressed
			as a linear combination of the terms $\configuration,
			\dot{\configuration}, \ddot{\configuration}$ with matrix
			coefficients. If this is the case, a substitution such as
			Equation~\ref{eq:linear_time_scaling} may be made to obtain a new
			trajectory $\configuration'$ and associated actuator torques
			$\torque'$ of the form:

			\begin{equation}
				\torque' =
					\invdynamicmodel
					(
						\configuration'(\timesym'),
						\dot{\configuration}'(\timesym')\gain,
						\ddot{\configuration}'(\timesym')\gain^2
					)
			\end{equation}

			Since $\invdynamicmodel$ is a sum of matrix multiplications,
			$\gain$ may be chosen to ensure $\torque' < \torque$.

		\subsubsection{Variable Scaling}%
		\label{sec:variable_scaling}

			The approaches of Section~\ref{sec:kinematic_scaling}
			and~\ref{sec:dynamic_scaling} rely on slowing down the execution of
			the trajectory to avoid saturation limits. It is worth noting that,
			instead of slowing down the global trajectory, a smart approach
			might be to only slow down only those sections of the trajectory
			that are too close to the saturation limits.  This will ensure that
			the constraints are met, while still avoiding unnecessarily slow
			motions.
