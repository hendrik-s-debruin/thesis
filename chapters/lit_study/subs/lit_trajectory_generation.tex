\section{Trajectory Generation}%
\label{sec:trajectory_generation}

	The problem of trajectory generation can be categorised into one-dimensional
	and multi-dimensional trajectories. Techniques exist to generate
	point-to-point trajectories, as well as to generate trajectories that visit
	multiple points. The latter case can be further subdivided into trajectories
	that visit each point exactly (known as interpolation techniques) and
	trajectories that come within a specified tolerance of each point (know as
	approximation techniques). \todo{maybe cite trajectory book p 2 here}
	\todo{maybe give image representation of categories?}

	One-dimensional trajectories can often be generalised for the
	multi-dimensional case. As such,
	Section~\ref{sec:one_dimensional_trajectory_generation} gives an overview of
	such techniques. Section~\ref{sec:multi_dimensional_trajectory_generation}
	gives an overview of trajectory generation techniques that are directly
	suited for the multi-dimensional case. Finally, trajectories may be subject
	to constraints on maximum velocity, acceleration, jerk, or higher
	derivatives.  Section~\ref{sec:trajectory_scaling} reviews methods to deal
	such constraints.

	\subsection{One Dimensional Trajectory Generation}%
	\label{sec:one_dimensional_trajectory_generation}

		There are several elementary trajectories that can be used to obtain a
		desired one-dimensional behaviour. Trajectories can also be added
		together to satisfy some other constraints. \todo{describe better}

		\todo{Discuss need for continuity in position profile and its
		derivatives up to a given order, need for boundary conditions. See
		notes, section 2.4}

		\subsubsection{Elementary Trajectories}%
		\label{sec:elementary_trajectories}

			\paragraph{Polynomial Trajectories}%
			\label{sec:polynomial_trajectories}

				Given the boundary conditions in position, velocity,
				acceleration, jerk, or higher derivatives for $\timesym \in
				\{\timesym_0, \timesym_{\final}\}$, a polynomial of higher
				degree can be fitted to satisfy the conditions. \todo{wording}
				\todo{what is the minimum degree?}

				We can write the normalised polynomial as:

				\begin{equation}
					\configuration(\timenorm) = \sum_{\indexi=0}^{\poldeg}
						\coefficient_{\indexi} \timenorm^{\indexi}
				\end{equation}

				This may be rewritten in matrix form as follows:

				\begin{equation}
					\mat{M}\vec{\coefficient} = \vec{b}
					\label{eq:polynomial_coefficient_equation}
				\end{equation}
				\todo{put these symbols into the nomenclature}

				Where the coefficients to be solved are put into
				\(
					\vec{\coefficient} =
						{
							\left[
								\begin{matrix}
									\coefficient_0 &
									\cdots &
									\coefficient_{\poldeg}
								\end{matrix}
							\right]
						}^T
				\),
				the boundary conditions are
				\(
					\vec{b} =
						{
							\left[
								\begin{matrix}
									\configuration_0 &
									\dot{\configuration}_0 &
									\cdots &
									\tdern{\configuration_0}{n} &
									\configuration_{\final} &
									\dot{\configuration}_{\final} &
									\cdots &
									\tdern{\configuration_{\final}}{n}
								\end{matrix}
							\right]
						}^T
				\)
				and $\mat{M}$ is filled using the boundary conditions of the
				polynomial.

				In principle, we can then simply obtain the trajectory by
				setting

				\begin{equation}
					\vec{\coefficient} = {\mat{M}}^{-1}\vec{b}
				\end{equation}

				However, taking the inverse of a matrix explicitly like this can
				lead to numerical instability even for a low degree polynomial.
				Other numerical techniques should be used for poorly conditioned
				matrices. \todo{either explain one (p 41 ish), or say where to
				get it}

			\paragraph{Trigonometric Trajectories}%
			\label{trigonometric_trajectories}

				Several types of trajectories can be generated by using
				trigonometric functions. Such trajectories have the advantage
				that they are of type
				\(
					\contdeg{\infty}
				\), with non-zero derivatives
				\(
					\forall \timenorm \in [0, 1]
				\).
				If proper care is taken in defining the boundary conditions,
				these trajectories can be used for continuous cyclic motions.
				\todo{fix continuity degree in nomenclature definition}

				\todo{change layout here}
				\todo{maybe normalise the equations}
				\begin{itemize}

					\item %HARMONIC

						Harmonic Trajectories are designed such that the
						acceleration of the trajectory is proportional to its
						position. Such trajectories are expressed by:

						\begin{equation}
							\configuration(\timesym) =
								\frac{%
										\configuration_{\final} - \configuration_0
									}
									{%
										2
									}
								\left(
									1 - \cos
										\frac{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
								\right)
								+ \configuration_0
						\end{equation}

						Note that this trajectory is discontinuous in its
						acceleration profile at the boundaries.

					\item %ELLIPTICAL

						Elliptical trajectories are a generalised form of
						harmonic trajectories.  They are of the following form:

						\begin{equation}
							\configuration(\timesym) =
								\frac
								{%
									\configuration_{\final} - \configuration_0
								}
								{%
									2
								}
								\left(
									1 -
									\frac
									{%
										\cos\frac
											{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
									}
									{%
										\sqrt
										{%
											1 -
											\frac
											{%
												n^2 - 1
											}
											{%
												n^2
											}
											\sin^2\frac
											{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
										}
									}
								\right)
						\end{equation}
						\todo{$n$ here is not in nomenclature}

						Here, $n$ may be tuned. Higher values of $n$ lead to
						higher values maxima in the time derivatives of
						position.
						\todo{what is the point of this trajectory?}
						\todo{explain why I call it time derivatives of
						position, and not acceleration etc.}

					\item %CYCLOIDAL

						Cycloidal trajectories obtain a continuous acceleration
						profile
						\(
							\forall \timesym \in [\timesym_0, \timesym_{\final}]
						\).
						These are given by the expression:

						\begin{equation}
							\configuration(\timesym) =
								(\configuration_{\final} - \configuration_0)
								\left(
									\frac
									{%
										\timesym - \timesym_0
									}
									{%
										\timesym_{\final} - \timesym_0
									}
									-
									\frac
									{%
										1
									}
									{%
										2\pi
									}
									\sin
										\frac
										{%
											2\pi(\timesym - \timesym_0)
										}
										{%
											\timesym_{\final} - \timesym_0
										}
								\right)
								+ \configuration_0
						\end{equation}

						Due to the continuous acceleration profile, these
						trajectories are suitable for mechanisms with flexible
						components.

				\end{itemize}

			\paragraph{Exponential Trajectories}%
			\label{exponential_trajectories}

				Exponential trajectories may be constructed such that the degree
				of continuity of the trajectory may be
				adjusted~\cite{bib:traj:cam_mechanisms}.  These trajectories are
				exponential in their velocity profiles, therefore their position
				profile is given by the following expression:

				\begin{equation}
					\configuration(\timenorm) = v_c \int_{0}^{\timenorm}
						e^{-\sigma f(\timenorm, \lambda)} \der \timenorm
				\end{equation}
				\todo{These parameters are not in the nomenclature}

				A popular choice for $f$ is~\cite[][page 48]{bib:traj:trajectory_planning_for_automatic_machines_and_robots}:

				\begin{equation}
					f(\timenorm, \lambda) =
						\frac
						{%
							{(2\timenorm)}^2
						}
						{%
							{%
								\left|
									1 - {(2\timenorm)}^2
								\right|
							}^\lambda
						}
				\end{equation}
				\todo{These parameters are not in the nomenclature}

				$\sigma$ and $\lambda$\todo{nomenclature} may be chosen to
				minimise high frequency components in the acceleration. By
				tuning these parameters, vibrations induced by the trajectory
				can be lowered.

			\paragraph{Trajectories Based on Fourier Series Expansion}%
			\label{trajectories_based_on_fourier_series_expansion}

				Given any of the previous trajectories of this section, one may
				want to attempt to limit vibrations induced by the trajectory.
				One method, which is especially useful for periodic
				trajectories, is the use of Fourier series expansion.

				A trajectory $\configuration(\timesym)$ may be transformed as
				follows:

				\begin{enumerate}

					\item

						Expand $\configuration(\timesym)$ into its Fourier
						series.

					\item

						Take the first $n$ terms of this series and use it to
						define a new trajectory $\configuration'(\timesym)$.
				\end{enumerate}
				\todo{$n$ is not in nomenclature}

				The number of terms, $n$, of the expansion to use compromises a
				trade-off: higher $n$ leads to lower maximum acceleration, but
				higher frequency components. $n$ in this case is a tuning
				parameter.
				\todo{$n$ is not in nomenclature}

		\subsubsection{Trajectory Composition}%
		\label{sec:trajetory_composition}

			Trajectories such as those presented in
			Section~\ref{sec:elementary_trajectories} may be combined to obtain
			new trajectories. The problem is then to smoothly connect these
			trajectories with trajectory segments referred to as
			``bends''~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots}.

			Many of the composition techniques break the trajectory into the
			following parts:

			\begin{enumerate}

				\item acceleration phase

				\item trajectory phase

				\item deceleration phase

			\end{enumerate}
			\todo{this list is probably stupid}

			\paragraph{Circular Bends}%
			\label{circular_bends}

				Circular Bends can be added to the position profile of a linear
				trajectory to start the trajectory segment from rest or to bring
				it to rest. Given a base linear trajectory,
				$\configuration(\timesym)$, the full trajectory
				$\configuration'(\timesym)$ is given  by:

				\begin{equation}
					\configuration'(\timesym) =
						\begin{cases}
							(\configuration_{\final} - \configuration_0)
							\left(
								1 - \sqrt
									{%
										1 - \frac
											{%
												{(\timesym - \timesym_0)}^2
											}
											{%
												{(\configuration_{\final} -
												\configuration_0)}^2
											}
									}
							\right)
							+ \configuration_0
							%
							& \timesym \in [\timesym_0, \timesym_a]
							%
							\\
							%
							\configuration(\timesym)
							%
							& \timesym \in [\timesym_a, \timesym_b]
							%
							\\
							%
							\configuration_0 +
								\sqrt
									{%
										{(\configuration_{\final} -
										\configuration_0)}^2
										-
										{(\timesym_{\final} - \timesym)}^2
									}
							%
							& \timesym \in [\timesym_b, \timesym_{\final}]
						\end{cases}
				\end{equation}
				\todo{$a$ and $b$ are not in nomenclature}

				The time intervals must be chosen such that:

				\begin{equation}
					\begin{cases}
						\configuration'(\timesym \in [\timesym_0,
							\timesym_a])|_{\timesym_a}
							=
							\configuration'(\timesym \in [\timesym_a,
								\timesym_b])|_{\timesym_a}
						%
						\\
						%
						\dot{\configuration}'(\timesym \in [\timesym_0,
							\timesym_a])|_{\timesym_a}
							=
							\dot{\configuration}'(\timesym \in [\timesym_a,
								\timesym_b])|_{\timesym_a}
					\end{cases}
				\end{equation}
				\todo{$a$ and $b$ are not in nomenclature}

			\paragraph{Polynomial Bends}%
			\label{polynomial_bends}

				Another method of starting or stopping a trajectory, or of
				joining different trajectory segments, is through the use of
				polynomial bends. The degree of smoothness of the connections
				can be controlled by choosing the degree of the polynomial
				bends. Given a base trajectory, $\configuration(\timesym)$, a
				new trajectory with polynomial bends,
				$\configuration'(\timesym)$ can be defined as follows:

				\begin{equation}
					\configuration'(\timesym) =
					\begin{cases}
						\configuration_a(\timesym) & \timesym \in [\timesym_0, \timesym_a] \\
						\configuration(\timesym) & \timesym \in [\timesym_a, \timesym_b] \\
						\configuration_b(\timesym) & \timesym \in [\timesym_b, \timesym_{\final}] \\
					\end{cases}
					\label{eq:polynomial_bends}
				\end{equation}
				\todo{$a$ and $b$ are not in nomenclature}

				Here, $\configuration_a$ and $\configuration_b$ may be computed
				using the polynomial trajectory method of
				Section~\ref{sec:elementary_trajectories}.

			%	\todo{for this section, reference bookref 17. The book
			%	references it on page 117. This section is a combination of
			%	various sections from the book}

			\todo{maybe add a discussion on the trapezoidal trajectories?}

			\paragraph{Cycloidal and Harmonic Blends}%
			\label{cycloidal_and_harmonic_blends}

				We may also connect trajectory segments with sinusoidal
				profiles described in Section~\ref{sec:elementary_trajectories}.
				The clear advantage of these bends are that they are of type
				$\contdeg{\infty}$.

				Again, the new trajectory $\configuration'(\timesym)$ is given
				by Equation~\ref{eq:polynomial_bends}, where
				$\configuration_a(\timesym)$ and $\configuration_b(\timesym)$
				are now one of the trigonometric functions of
				Section~\ref{sec:elementary_trajectories}.
				\todo{$a$ and $b$ are not in nomenclature}

	\subsection{Multipoint Trajectories}%
	\label{sec:multipoint_trajectories}

		The techniques from
		Section~\ref{sec:one_dimensional_trajectory_generation} are concerned
		with generating trajectories between two points. The present section
		documents methods to generate a trajectory that goes through all the
		points $\point$ in a given set of points $\setofpoints$.

		\todo{Say that there are trajectories which interpolate, as well as
		trajectories which approximate. Todo, write about these}

		One approach to multipoint trajectories is to define a set of primitive
		trajectories, such as straight lines or circles, and then to connect
		these disjoint trajectories smoothly with the blending techniques
		discussed in Section~\ref{sec:trajetory_composition}. The remainder of
		this section will review other approaches to multi-point trajectory
		generation.

		\subsubsection{Interpolation Techniques}%
		\label{sec:interpolation_techniques}

			\paragraph{Multipoint Polynomial Trajectories}%
			\label{sec:multipoint_polynomial_trajectories}


				The polynomial method of
				Section~\ref{sec:polynomial_trajectories} can be extended to
				exactly interpolate a set of points. This is done by simply
				adjusting the vector \todo{this vector is not in the
				nomenclature and is the same symbol as used in the other
				polynomial section. If it is added to nomencl there/changed
				there, the same must be done here} $\vec{b}$ to also include the
				intermediate points. A polynomial of degree $\poldeg$ can be
				used to interpolate $\poldeg + 1$ points.

				The main disadvantage is that polynomials tend to overshoot a
				lot between points.

			\paragraph{Trigonometric Polynomials}%
			\label{sec:trigonometric_polynomials}

				Trigonometric polynomials are similar to regular polynomials,
				except they are suitable for periodic
				motions~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots}.
				By definition, these trajectories are of type
				$\contdeg{\infty}$. They are given by the expression:

				\begin{equation}
					\configuration(\timesym) =
						\coefficient_0 +
						%
						\sum_{\indexi = 1}^{\poldeg} \coefficient_{\indexi}
							\cos
							\left(
								\indexi\frac
								{%
									2\pi\timesym
								}
								{%
									\period
								}
							\right)
						%
						+
						%
						\sum_{\indexi = 1}^{\poldeg}\coefficientb_{\indexi}
							\sin
							\left(
								\indexi\frac{%
									2\pi\timesym
								}
								{%
									\period
								}
							\right)
				\end{equation}

				The degree of the polynomial $\poldeg$ is chosen such that
				$\cardinality{\setofpoints} = 2\poldeg + 1$. The coefficients
				are solved using the same method of polynomial trajectories. A
				set of these polynomials may be joined to form a trigonometric
				spline. %\todo{ref book ref 27, 28, 29. See p 175}

			\paragraph{Splines}%
			\label{sec:splines}

				$\cardinality{\setofpoints} - 1$ polynomials of degree usually
				set to $\poldeg \leq \cardinality{\setofpoints} - 2$ may be used
				to form a spline interpolation. The main idea is to use each
				polynomial to interpolate between two points. The polynomial
				degree $\poldeg$ and the boundary conditions in
				Equation~\ref{eq:polynomial_coefficient_equation} are then
				chosen to ensure that the splines meet with a desired level of
				continuity.

				A common choice for the degree of the polynomial is $\poldeg =
				3$. This ensures that accelerations remain continuous at the
				transitions. Furthermore, it is easy to set the start and end
				conditions to be continuous up to a required degree in order to
				make the trajectories periodic.

		\subsubsection{Approximation Techniques}%
		\label{sec:approximation_techniques}

			\todo{orthogonal polynomials --- p 165}

			\paragraph{Smoothing Cubic Splines}%
			\label{sec:smoothing_cubic_splines}

				Smoothing cubic splines are an adaptation on the spline
				interpolation of Section~\ref{sec:splines}. They try to have as
				good as possible a fit of the points in $\setofpoints$, yet try
				to limit the curvature of the trajectory. This tends to reduce
				the acceleration profile.

				Such trajectories try to solve for the spline polynomials
				$\polynomial$ satisfying:

				\begin{equation}
					\arg\min_{\polynomial}
					\left\{
						\relweight
						\underbrace{%
							\sum_{\indexi = 0}^{\cardinality{\setofpoints}}
								\gain_{\indexi}
								{%
									\left(
										\polynomial(\timesym_{\indexi}) -
										\point_{\indexi}
									\right)
								}^2
						}_{\text{error in approximation}}
						+
						(1 - \relweight)
						\underbrace{%
							\int_{\timesym_0}^{\timesym_{\cardinality{\setofpoints}}}
								\ddot{\polynomial}^2
							\der \timesym
						}_{\text{curvature}}
					\right\}
					\label{eq:smoothing_cubic_splines_criterion}
				\end{equation}
				\todo{fix argmin}

				An algorithm based on linear algebra techniques to solve
				Equation~\ref{eq:smoothing_cubic_splines_criterion} can be found
				in~\cite[][page 180]{bib:traj:trajectory_planning_for_automatic_machines_and_robots}.

				The maximum approximation error can be guaranteed by performing
				a simple search technique, such as binary search, on the
				parameter $\relweight$.

	\subsection{Multi-Dimensional Trajectory Generation}%
	\label{sec:multi_dimensional_trajectory_generation}

		It is often possible to decompose multi-dimensional trajectories into
		simpler components. Trajectories for these components may be handled by
		the techniques discussed in
		Sections~\ref{sec:one_dimensional_trajectory_generation}
		and~\ref{sec:multipoint_trajectories}. The remainder of this section
		deals with trajectory generation techniques that deal directly with the
		multi-dimensional case.

		The trajectories given in this section are of the form
		$\traj(\timenorm)$. Here, the trajectory $\traj$ defines a curve in
		space. $\timenorm(\timesym)$ acts as a motion law that determines when
		certain points in the trajectory are reached. Therefore, a trajectory
		for $\timenorm$ can be generated with any of the one dimensional methods
		described in Section~\ref{sec:one_dimensional_trajectory_generation}
		or~\ref{sec:multipoint_trajectories}. The motion law $\timenorm$ can
		also be chosen to adhere to some kinematic and dynamic constraints.
		Section~\ref{sec:trajectory_scaling} deals with this.

		\subsubsection{Multi-Dimensional Interpolation Trajectories}%
		\label{sec:multi_dimensional_interpolation_trajectories}

			\paragraph{B-Splines}%
			\label{sec:b_spines}

				B-splines are a common method to interpolate between points
				$\point$ in a given set
				$\setofpoints$~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots}\cite{bib:traj:handbook_on_splines_for_the_user}.
				They are given by the relation:

				\begin{equation}
					\traj = \sum_{\indexi = 0}^{\cardinality{\setofpoints}}
						\point_{\indexi}\bspline_{\indexi}^{\poldeg}(\timenorm)
					\label{eq:bspline}
				\end{equation}

				Where the superscript denotes the degree of the spline
				$\bspline$. The points $\point_{\indexi}$ are known as the
				control points of Equation~\ref{eq:bspline}.  Each B-spline
				meets at a point known as a knot $\knot$. Given an ordered set
				of knots such that
				\(
					\knot_{\indexi} \prec \knot_{\indexj} \iff \indexi < \indexj
				\), a basis spline $\bspline$ is defined as follows:

				\begin{align}
					\begin{split}
						\bspline_{\indexi}^0(\timenorm) &=
							\begin{cases}
								1, & \timenorm \in [\knot_{\indexi}, \knot_{\indexi + 1}]\\
								0, & \text{otherwise}
							\end{cases}
						%
						\\
						%
						\bspline_{\indexi}^{\poldeg}(\timenorm) &=
							\frac
							{%
								\timenorm - \knot_{\indexi}
							}
							{%
								\knot_{\indexi + \poldeg} - \knot_{\indexi}
							}
							\bspline_{\indexi}^{\poldeg - 1}(\timenorm)
							+
							\frac
							{%
								\knot_{\indexi + \poldeg + 1} - \timenorm
							}
							{%
								\knot_{\indexi + \poldeg + 1} - \knot_{\indexi + 1}
							}
							\bspline_{\indexi + 1}^{\poldeg - 1}(\timenorm)
							,
							\quad \poldeg > 0
						\label{eq:bspline_interpolation_generation}
						\end{split}
				\end{align}

				%The following constraint is added to normalise the spline
				%functions:

				%\begin{equation}
				%	\sum_{\indexi = 0}^{\cardinality{\setofpoints}}
				%		\bspline_{\indexi}^{\poldeg}(\timenorm)
				%		=
				%		1
				%		\quad \forall \timenorm
				%\end{equation}

				Setting the degree of the B-spline curve to $\poldeg$ imposes a
				continuity level of $\contdeggeom{\poldeg - 1}$.
				\todo{continuity degree, geometric continuity degree are not
				showing up in nomenclature}

		\subsubsection{Multi-Dimensional Approximation Trajectories}%
		\label{sec:multi_dimensional_approximation_trajectories}

			\paragraph{Linear Interpolation with Polynomial Bends}%
			\label{sec:linear_interpolation_with_polynomial_bends}

				Linear interpolation with polynomial bends is a very simple way
				to approximate the points $\point\in\setofpoints$ to within a
				specifiable tolerance $\tol$ and a specified degree of
				smoothness. Consider an ordered set of points $\setofpoints$
				such that $\point_{\indexi} \prec \point_{\indexj} \iff \indexi
				\leq \indexj$. For the internal points the following basic
				algorithm can be used to generate an interpolation
				\(
					\forall \point \in
						\setofpoints\setminus
							\left\{
								\point_0,
								\point_{\cardinality{\setofpoints}}
							\right\}
				\):

				\begin{enumerate}

					\item

						Construct a (hyper)sphere of radius $\tol$ around point
						$\point_{\indexi}$.

					\item

						Connect points
						\(
							(
								\point_{\indexi - 1},
								\point_{\indexi},
								\point_{\indexi + 1}
							)
						\)
						with the straight lines
						\(
							\vecline{
								\point_{\indexi -1}
							}
							{
								\point_{\indexi}
							}
						\)
						and
						\(
							\vecline{
								\point_{\indexi}
							}
							{
								\point_{\indexi+1}
							}
						\).

					\item

						Mark the intersection of the line
						\(
							\vecline{
								\point_{\indexi -1}
							}
							{
								\point_{\indexi}
							}
						\)
						and the sphere as the point $\point_{\indexi}'$, and the
						intersection of the line
						\(
							\vecline{
								\point_{\indexi}
							}
							{
								\point_{\indexi+1}
							}
						\) and the sphere as the point $\point_{\indexi}''$.

					\item

						The trajectory $\traj$ that is guaranteed to come within
						$\tol$ of the current point $\point_{\indexi}$
						is then defined by:

						\begin{equation}
							\traj_{\indexi}(\timenorm) =
								\begin{cases}
									\vecline{%
										\point_{\indexi -1}
									}
									{%
										\point_{\indexi}
									},
									& \traj(\timenorm)\mapsto
										[
											\point_{\indexi-1},
											\point_{\indexi}'
										]
									%
									\\
									%
									\traj'(\timenorm),
									& \traj(\timenorm)\mapsto
										[
											\point_{\indexi}',
											\point_{\indexi}''
										]
									%
									\\
									%
									\vecline{%
										\point_{\indexi}
									}
									{%
										\point_{\indexi+1}
									},
									& \traj(\timenorm)\mapsto
										[
											\point_{\indexi}'',
											\point_{\indexi+1}
										]
								\end{cases}
						\end{equation}

						Where $\traj'$ is the part of the trajectory $\traj$
						between points $\point_{\indexi}'$ and
						$\point_{\indexi}''$ and is given by a polynomial
						function such as a B-spline discussed in
						Section~\ref{sec:b_spines}. The result is straight lines
						smoothly connected with bends.

				\end{enumerate}

				The end points of $\setofpoints$,  points $\point_0$ and
				$\point_{\cardinality{\setofpoints}}$, may be connected to
				their following/preceding points by simple straight lines.

				\begin{figure}[hb]
					\centering
					\def\svgwidth{\columnwidth}
					\import{res/img/}{linear_interpolation_with_polynomial_bends.pdf_tex}
					\caption[Linear Interpolation with Polynomial Bends]
						{Linear Interpolation with Polynomial Bends (adapted
						from~\cite{bib:traj:trajectory_planning_for_automatic_machines_and_robots})}%
					\label{fig:linear_interpolation_with_polynomial_bends}
				\end{figure}

			\paragraph{Smoothing Cubic B-Splines}%
			\label{sec:smoothing_cubic_b_splines}

				In a spirit similar to smoothing cubic splines, B-splines may be
				made to approximate points to within a given tolerance $\tol$.
				The splines are of the form in Equation~\ref{eq:bspline}.

				A smoothing cubic B-spline is defined by a set of points $\point
				\in \setofpoints$ which need to be approximated by the control
				points $\approximation{\point} \in \approximation{\setofpoints}$
				(which replace the points $\point$ in Equation~\ref{eq:bspline})
				at given points of time $\timenorm \in \setoftimeinstants$.
				Instead of defining the splines with the recursive procedure
				given in Equation~\ref{eq:bspline_interpolation_generation}, a
				minimisation needs to be performed. This minimisation is
				analogous to the cubic spline case,
				Equation~\ref{eq:smoothing_cubic_splines_criterion}, and is
				given by the expression:

				\begin{equation}
					\approximation{\setofpoints} =
					\arg\min_{\approximation{\setofpoints}}
					\left\{
						\relweight
						\underbrace{%
							\sum_{\indexi = 0}^{\cardinality{\setofpoints}}
								\gain_{\indexi}
								{%
									\norm{%
										\traj(\timenorm_{\indexi}) -
										\point_{\indexi}
									}
								}^2
						}_{\text{error in approximation}}
						+
						(1 - \relweight)
						\underbrace{%
							\int_{\timesym_0}^{\timesym_{\cardinality{\setofpoints}}}
								{%
									\norm
									{%
										\frac
										{%
											\der^2 \traj(\timenorm)
										}
										{%
											\der\timenorm^2
										}
									}
								}^2
							\der \timenorm
						}_{\text{total curvature}}
					\right\}
					\label{eq:smoothing_b_splines_criterion}
				\end{equation}
				\todo{fix argmin}

				Note that $\gain_{\indexi}$ may be set to change the
				approximation error in some specific points. A methodology to
				perform this minimisation can be found in~\cite[][page
				371]{bib:traj:trajectory_planning_for_automatic_machines_and_robots}

			\todo{Mixed Interpolation/Approximation, book p 375}


	\subsection{Trajectory Scaling}%
	\label{sec:trajectory_scaling}

		Given a trajectory $\configuration(\timesym)$, one may perform several
		scaling techniques to ensure actuators do not exceed saturation
		constraints. Trajectories may be scaled to avoid kinematic saturation
		(that is, saturation in velocities, acceleration or higher derivatives),
		or to avoid dynamic saturation (that is, saturation in the torques
		induced in the actuators).

		\subsubsection{Kinematic Scaling}%
		\label{sec:kinematic_scaling}

			Given a trajectory $\configuration(\timesym)$, it is possible to
			alter the time it takes by considering a new time variable
			$\timesym'$ related to $\timesym$ through some relation:

			\begin{equation}
				\timesym = f(\timesym')
				\label{eq:time_scaling}
			\end{equation}
			\todo{$f$ is not in nomenclature. Used throughout this section}

			Where $f$ is a strictly increasing function. The new trajectory
			$\configuration'(\timesym')$ and its higher derivates are given by
			the chain rule as:

			\begin{align}
				\begin{split}
					\configuration'(\timesym') &= \configuration(f(\timesym'))\\
					%
					\dot{\configuration}'(\timesym') &=
						\frac
						{%
							\der \configuration(f)
						}
						{%
							\der f
						}
						\frac
						{%
							\der f(\timesym')
						}
						{%
							\der \timesym'
						}\\
					%
					\ddot{\configuration}'(\timesym') &=
						\frac
						{%
							\der \configuration(f)
						}
						{%
							\der f
						}
						\frac
						{%
							\der^2 f(\timesym')
						}
						{%
							\der \timesym'^2
						}
						+
						\frac
						{%
							\der^2 \configuration(f)
						}
						{%
							\der \configuration^2
						}
						{%
							\left(
								\frac
								{%
									\der f(\timesym')
								}
								{%
									\der \timesym'
								}
							\right)
						}^2\\
						%
						&\quad\quad\quad\quad\quad\quad\quad\vdots
					\label{eq:kinematic_scaling_general}
				\end{split}
			\end{align}

			A simple example for $f$ is the linear function:

			\begin{equation}
				\timesym = \gain\timesym'
				\label{eq:linear_time_scaling}
			\end{equation}

			In this case, Equation~\ref{eq:kinematic_scaling_general} reduces
			to:

			\begin{equation}
				\tdern{\configuration'}{n}(\timesym') = \gain^{n}
					\tdern{\configuration}{n}(\timesym)
			\end{equation}
			\todo{$n$ here is not in nomenclature}

			Now, given a set of constraints $\setofconstraints$ on the maximum
			velocity, acceleration, or higher derivatives of a trajectory,
			$\gain$ may be chosen as follows:

			\begin{equation}
				\gain = \min
					\left\{
						\sqrt[\indexi]
						{%
							\frac
							{%
								\constraint_{\indexi}
							}
							{%
									\norm
									{%
										\tdern{\configuration}{\indexi}(\timesym)
									}_{\max}
							}
						}
						\quad
						\forall \constraint_{\indexi} \in \setofconstraints
					\right\}
			\end{equation}

			Where $\constraint_{\indexi}$ is the constraint on the $\indexi$th
			derivative of position. This will ensure that $\configuration'$ does
			not exceed these constraints.
			\todo{I think the book had its own references here too}

		\subsubsection{Dynamic Scaling}%
		\label{sec:dynamic_scaling}

			Given the dynamic model of a system, $\dynamicmodel(\torque)$, the
			same time scaling approach as given in
			Equation~\ref{eq:time_scaling} can be used.

			The torques in the actuators are given by:

			\begin{equation}
				\torque = \invdynamicmodel(\configuration, \dot{\configuration},
					\ddot{\configuration})
				\label{eq:inv_dynamic_model_scaling}
			\end{equation}

			Equation~\ref{eq:inv_dynamic_model_scaling} can usually be expressed
			as a linear combination of the terms $\configuration,
			\dot{\configuration}, \ddot{\configuration}$ with matrix
			coefficients. If this is the case, a substitution such as
			Equation~\ref{eq:linear_time_scaling} may be made to obtain a new
			trajectory $\configuration'$ and associated actuator torques
			$\torque'$ of the form:

			\begin{equation}
				\torque' =
					\invdynamicmodel
					(
						\configuration'(\timesym'),
						\dot{\configuration}'(\timesym')\gain,
						\ddot{\configuration}'(\timesym')\gain^2
					)
			\end{equation}

			Since $\invdynamicmodel$ is a sum of matrix multiplications,
			$\gain$ may be chosen to ensure $\torque' < \torque$.
			\todo{make sure I didn't confuse direct and indirect models in this
			section}


		\subsubsection{Variable Scaling}%
		\label{sec:variable_scaling}

			The approaches of Section~\ref{sec:kinematic_scaling}
			and~\ref{sec:dynamic_scaling} rely on slowing down the execution of
			the trajectory to avoid saturation limits. It is worth noting that,
			instead of slowing down the global trajectory, a smart approach
			might be to only slow down only those sections of the trajectory
			that are too close to the saturation limits.  This will ensure that
			the constraints are met, while still avoiding unnecessarily slow
			motions.
