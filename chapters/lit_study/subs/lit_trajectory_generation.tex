\section{Trajectory Generation}%
\label{sec:trajectory_generation}

	The problem of trajectory generation can be categorised into one-dimensional
	and multi-dimensional trajectories. Techniques exist to generate
	point-to-point trajectories, as well as to generate trajectories that visit
	multiple points. The latter case can be further subdivided into trajectories
	that visit each point exactly (known as interpolation techniques) and
	trajectories that come within a specified tolerance of each point (know as
	approximation techniques). \todo{maybe cite trajectory book p 2 here}
	\todo{maybe give image representation of categories?}

	One-dimensional trajectories can often be generalised for the
	multi-dimensional case. As such,
	Section~\ref{sec:one_dimensional_trajectory_generation} gives an overview of
	such techniques. Section~\ref{sec:multi_dimensional_trajectory_generation}
	gives an overview of trajectory generation techniques that are directly
	suited for the multi-dimensional case. Finally, trajectories may be subject
	to constraints on maximum velocity, acceleration, jerk, or higher
	derivatives.  Section~\ref{sec:trajectory_scaling} reviews methods to deal
	such constraints.

	\subsection{One Dimensional Trajectory Generation}%
	\label{sec:one_dimensional_trajectory_generation}

		There are several elementary trajectories that can be used to obtain a
		desired one-dimensional behaviour. Trajectories can also be added
		together to satisfy some other constraints. \todo{describe better}

		\todo{Discuss need for continuity in position profile and its
		derivatives up to a given order, need for boundary conditions. See
		notes, section 2.4}

		\subsubsection{Elementary Trajectories}%
		\label{sec:elementary_trajectories}

			\paragraph{Polynomial Trajectories}

				Given the boundary conditions in position, velocity,
				acceleration, jerk, or higher derivatives for $\timesym \in
				\{\timesym_0, \timesym_{\final}\}$, a polynomial of higher
				degree can be fitted to satisfy the conditions. \todo{wording}
				\todo{what is the minimum degree?}

				We can write the normalised polynomial as:

				\begin{equation}
					\configuration(\timenorm) = \sum_{\indexi=0}^{\poldeg}
						\coefficient_{\indexi} \timenorm^{\indexi}
				\end{equation}

				This may be rewritten in matrix form as follows:

				\begin{equation}
					\mat{M}\vec{\coefficient} = \vec{b}
				\end{equation}
				\todo{put these symbols into the nomenclature}

				Where the coefficients to be solved are put into
				\(
					\vec{\coefficient} =
						{
							\left[
								\begin{matrix}
									\coefficient_0 &
									\cdots &
									\coefficient_{\poldeg}
								\end{matrix}
							\right]
						}^T
				\),
				the boundary conditions are
				\(
					\vec{b} =
						{
							\left[
								\begin{matrix}
									\configuration_0 &
									\dot{\configuration}_0 &
									\cdots &
									\tdern{\configuration_0}{n} &
									\configuration_{\final} &
									\dot{\configuration}_{\final} &
									\cdots &
									\tdern{\configuration_{\final}}{n} &
								\end{matrix}
							\right]
						}^T
				\)
				and $\mat{M}$ is filled using the boundary conditions of the
				polynomial.

				In principle, we can then simply obtain the trajectory by
				setting

				\begin{equation}
					\vec{\coefficient} = {\mat{M}}^{-1}\vec{b}
				\end{equation}

				However, taking the inverse of a matrix explicitly like this can
				lead to numerical instability even for a low degree polynomial.
				Other numerical techniques should be used for poorly conditioned
				matrices. \todo{either explain one (p 41 ish), or say where to
				get it}

			\paragraph{Trigonometric Trajectories}

				Several types of trajectories can be generated by using
				trigonometric functions. Such trajectories have the advantage
				that they are of type
				\(
					\contdeg{\infty}
				\), with non-zero derivatives
				\(
					\forall \timenorm \in [0, 1]
				\).
				If proper care is taken in defining the boundary conditions,
				these trajectories can be used for continuous cyclic motions.
				\todo{fix continuity degree in nomenclature definition}

				\todo{change layout here}
				\todo{maybe normalise the equations}
				\begin{itemize}

					\item %HARMONIC

						Harmonic Trajectories are designed such that the
						acceleration of the trajectory is proportional to its
						position. Such trajectories are expressed by:

						\begin{equation}
							\configuration(\timesym) =
								\frac{%
										\configuration_{\final} - \configuration_0
									}
									{%
										2
									}
								\left(
									1 - \cos
										\frac{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
								\right)
								+ \configuration_0
						\end{equation}

						Note that this trajectory is discontinuous in its
						acceleration profile at the boundaries.

					\item %ELLIPTICAL

						Harmonic trajectories may be generalised to obtain
						elliptical trajectories. They are of the following form:

						\begin{equation}
							\configuration(\timesym) =
								\frac
								{%
									\configuration_{\final} - \configuration_0
								}
								{%
									2
								}
								\left(
									1 -
									\frac
									{%
										\cos\frac
											{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
									}
									{%
										\sqrt
										{%
											1 -
											\frac
											{%
												n^2 - 1
											}
											{%
												n^2
											}
											\sin^2\frac
											{%
												\pi(\timesym - \timesym_0)
											}
											{%
												\timesym_{\final} - \timesym_0
											}
										}
									}
								\right)
						\end{equation}
						\todo{$n$ here is not in nomenclature}

						Here, $n$ may be tuned. Higher values of $n$ lead to
						higher values maxima in the time derivatives of
						position.
						\todo{what is the point of this trajectory?}
						\todo{explain why I call it time derivatives of
						position, and not acceleration etc.}

					\item %CYCLOIDAL

						Cycloidal trajectories obtain a continuous acceleration
						profile
						\(
							\forall \timesym \in [\timesym_0, \timesym_{\final}]
						\).
						These are given by the expression:

						\begin{equation}
							\configuration(\timesym) =
								(\configuration_{\final} - \configuration_0)
								\left(
									\frac
									{%
										\timesym - \timesym_0
									}
									{%
										\timesym_{\final} - \timesym_0
									}
									-
									\frac
									{%
										1
									}
									{%
										2\pi
									}
									\sin
										\frac
										{%
											2\pi(\timesym - \timesym_0)
										}
										{%
											\timesym_{\final} - \timesym_0
										}
								\right)
								+ \configuration_0
						\end{equation}

						Due to the continuous acceleration profile, these
						trajectories are suitable for mechanisms with flexible
						components.

				\end{itemize}

			\paragraph{Exponential Trajectories}

				Exponential trajectories may be constructed such that the
				degree of continuity of the trajectory may be adjusted.
				\todo{quote bookref 14} These trajectories are exponential in
				their velocity profiles, therefore their position profile is
				given by the following expression:

				\begin{equation}
					\configuration(\timenorm) = v_c \int_{0}^{\timenorm}
						e^{-\sigma f(\timenorm, \lambda)} \der \timenorm
				\end{equation}
				\todo{These parameters are not in the nomenclature}

				A popular choice \todo{put reference here} for $f$ is:

				\begin{equation}
					f(\timenorm, \lambda) =
						\frac
						{%
							{(2\timenorm)}^2
						}
						{%
							{%
								\left|
									1 - {(2\timenorm)}^2
								\right|
							}^\lambda
						}
				\end{equation}
				\todo{These parameters are not in the nomenclature}

				$\sigma$ and $\lambda$\todo{nomenclature} may be chosen to
				minimise high frequency components in the acceleration. By
				tuning these parameters, vibrations induced by the trajectory
				can be lowered.

			\paragraph{Trajectories Based on Fourier Series Expansion}

				Given any of the previous trajectories of this section, one may
				want to attempt to limit vibrations induced by the trajectory.
				One method, which is especially useful for periodic
				trajectories, is the use of Fourier series expansion.

				A trajectory $\configuration(\timesym)$ may be transformed as
				follows:

				\begin{enumerate}

					\item

						Expand $\configuration(\timesym)$ into its Fourier
						series.

					\item

						Take the first $n$ terms of this series and use it to
						define a new trajectory $\configuration'(\timesym)$.
				\end{enumerate}
				\todo{$n$ is not in nomenclature}

				The number of terms, $n$, of the expansion to use compromises a
				trade-off: higher $n$ leads to lower maximum acceleration, but
				higher frequency components. $n$ in this case is a tuning
				parameter.
				\todo{$n$ is not in nomenclature}

		\subsubsection{Trajectory Composition}%
		\label{sec:trajetory_composition}

			Trajectories such as those presented in
			Section~\ref{sec:elementary_trajectories} may be combined to obtain
			new trajectories. The problem is then to smoothly connect these
			trajectories with trajectory segments referred to as
			``bends''.\todo{make sure this sentence is not bullshit}

			Many of the composition techniques break the trajectory into the
			following parts:

			\begin{enumerate}

				\item acceleration phase

				\item trajectory phase

				\item deceleration phase

			\end{enumerate}
			\todo{this list is probably stupid}

			\paragraph{Circular Bends}

				Circular Bends can be used

			\paragraph{Linear Trajectory with Parabolic Bends}

			\paragraph{Linear Trajectory with Polynomial Bends}

			\paragraph{Trajectory with Double S velocity Profile}

	\subsection{Multi-Dimensional Trajectory Generation}%
	\label{sec:multi_dimensional_trajectory_generation}


	\subsection{Trajectory Scaling}%
	\label{sec:trajectory_scaling}

