\chapter{Motion Law}%
\label{chap:motion_law}

	The path found with the algorithms described in
	Chapter~\ref{chap:path_processing} can be considered as a continuous smooth
	mapping that adheres to:

	\begin{equation}
		\pathsym : \timenorm \in [0, 1] \mapsto \specialEuclideanGroup{3}
			\quad
			\suchthat
			\quad
			\pathsym(0) = \pose_{\initial}, \pathsym(1) = \pose_{\goal},
			\forall\obstacle\forall(\pose\in\pathsym)
				\robot(\pose) \cap \obstacle = \emptyset
	\end{equation}

	If $\timenorm$ is interpreted as time, then it would imply that the robot is
	in its initial pose at $\timesym = 0\si{\second}$ and reaches its goal pose
	at $\timesym = 1\si{\second}$. While $\pathsym$ is guaranteed to be free of
	collisions, this interpretation makes no guarantee that the actuators can
	move the end-effector this fast. For this reason, a motion law,
	$\motionlaw$, must be found that performs the following mapping:

	\begin{equation}
		\motionlaw: \timesym\in\Re \mapsto \timenorm\in[0, 1]
	\end{equation}

	The trajectory, $\traj:\timesym \mapsto \specialEuclideanGroup{3}$, can then
	be defined simply as:

	\begin{equation}
		\traj = \pathsym(\motionlaw(\timesym))
	\end{equation}

	In addition to the no-collision guarantees of $\pathsym$, $\traj$ also
	guarantees that the actuators stay within their saturation ranges. The
	present chapter describes the approach followed to find a suitable
	$\motionlaw$.

	\input{chapters/motion_law/subs/motion_law_generation_algorithm}
	\input{chapters/motion_law/subs/ensuring_smooth_start}
	\input{chapters/motion_law/subs/sample_motion_law_processing_output}
